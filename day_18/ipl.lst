     1 00000000                                 ; snail-ipl
     2 00000000                                 ; TAB=4
     3 00000000                                 	
     4  = 0000000A                              CYLS	EQU		10			; 宏定义
     5 00000000                                 
     6                                          		ORG	0x7c00			; 指明程序的装载地址, 0x7c00是主引导记录的内存地址
     7 00007C00                                 
     8 00007C00                                 ; 以下这段是标准FAT12格式软盘的专用代码
     9 00007C00                                 
    10 00007C00 EB 4E                           		JMP entry
    11 00007C02 90                              		DB	0x90
    12 00007C03 48 45 4C 4C 4F 49 50 54         		DB	"HELLOIPT"		; 启动区的名称可以是任意的字符串(8字节)
    13 00007C0B 0200                            		DW	512				; 每个扇区的大小(必须是512)
    14 00007C0D 01                              		DB	1				; 簇的大小(必须为1个扇区)
    15 00007C0E 0001                            		DW	1				; FAT的起始位置(一般从第一个扇区开始)
    16 00007C10 02                              		DB	2				; FAT的个数(必须为2)
    17 00007C11 00E0                            		DW	224				; 根目录的大小(一般设置成224项)
    18 00007C13 0B40                            		DW 	2880			; 该磁盘的大小(必须是2880扇区)
    19 00007C15 F0                              		DB	0xf0			; 磁盘的种类(必须是0xf0)
    20 00007C16 0009                            		DW	9				; FAT的长度(必须是9扇区)
    21 00007C18 0012                            		DW	18				; 1个磁道有几个扇区(必须是18)
    22 00007C1A 0002                            		DW	2				; 磁头数(必须是2)
    23 00007C1C 00000000                        		DD	0				; 不使用分区，必须是0
    24 00007C20 00000B40                        		DD 	2880			; 重写一次磁盘大小
    25 00007C24 00 00 29                        		DB	0,0,0x29		; 意义不明，固定
    26 00007C27 FFFFFFFF                        		DD	0xffffffff		; (可能是) 标卷号码
    27 00007C2B 53 4E 41 49 4C 2D 4F 53 20 20   		DB	"SNAIL-OS   "		; 磁盘的名称(11字节)
       00007C35 20 
    28 00007C36 46 41 54 31 32 20 20 20         		DB	"FAT12   "			; 磁盘格式的名称(8字节)
    29 00007C3E 00 00 00 00 00 00 00 00 00 00   		RESB	18			; 先空出18字节	
       00007C48 00 00 00 00 00 00 00 00 
    30 00007C50                                 
    31 00007C50                                 ; 程序核心
    32 00007C50                                 
    33 00007C50                                 entry:						; 是一个标签的声明, 用于指定JMP指令跳转的目的地等.
    34 00007C50 B8 0000                         		MOV	AX,0			; 初始化寄存器			
    35 00007C53 8E D0                           		MOV	SS,AX			
    36 00007C55 BC 7C00                         		MOV	SP,0x7c00
    37 00007C58 8E D8                           		MOV DS,AX
    38 00007C5A                                 
    39 00007C5A                                 ; 选择磁盘位置
    40 00007C5A B8 0820                         		MOV AX,0x0820			
    41 00007C5D 8E C0                           		MOV ES,AX
    42 00007C5F B5 00                           		MOV CH,0			; 柱面0
    43 00007C61 B6 00                           		MOV DH,0			; 磁头0
    44 00007C63 B1 02                           		MOV	CL,2			; 扇区2
    45 00007C65                                 
    46 00007C65                                 readloop:
    47 00007C65 BE 0000                         		MOV SI,0			; 记录失败次数的寄存器
    48 00007C68                                 
    49 00007C68                                 retry:
    50 00007C68 B4 02                           		MOV AH,0x02			; AH=0X02: 读盘
    51 00007C6A B0 01                           		MOV AL,1			; 1个扇区
    52 00007C6C BB 0000                         		MOV BX,0			
    53 00007C6F B2 00                           		MOV	DL,0x00			; A驱动器
    54 00007C71 CD 13                           		INT 0x13			; 调用磁盘BIOS, 会返回一个值，如果没有错就返回0，否则返回1
    55 00007C73 73 10                           		JNC next			; 没出错的话跳转到next
    56 00007C75 83 C6 01                        		ADD SI,1			; 往SI加1
    57 00007C78 83 FE 05                        		CMP SI,5			; 比较SI与5
    58 00007C7B 73 32                           		JAE error			; SI >= 5时, 跳转到ERROR
    59 00007C7D                                 
    60 00007C7D B4 00                           		MOV AH,0x00			; AH=0x00: 重置软盘状态
    61 00007C7F B2 00                           		MOV DL,0X00			; A驱动器
    62 00007C81 CD 13                           		INT 0x13			; 重置驱动器
    63 00007C83 EB E3                           		JMP retry
    64 00007C85                                 
    65 00007C85                                 next:
    66 00007C85 8C C0                           		MOV AX,ES			
    67 00007C87 05 0020                         		ADD AX,0x0020		; 把内存地址后移0x200(即512个字节，一个扇区)
    68 00007C8A 8E C0                           		MOV ES,AX			; 段寄存器无法直接作为操作数，所以这里使用了AX
    69 00007C8C 80 C1 01                        		ADD CL,1			; 往CL里加1
    70 00007C8F 80 F9 12                        		CMP CL,18			; 比较CL与18
    71 00007C92 76 D1                           		JBE	readloop		; 如果CL <= 18，跳转至readloop
    72 00007C94 B1 01                           		MOV CL,1			
    73 00007C96 80 C6 01                        		ADD DH,1		
    74 00007C99 80 FE 02                        		CMP DH,2
    75 00007C9C 72 C7                           		JB readloop
    76 00007C9E B6 00                           		MOV DH,0
    77 00007CA0 80 C5 01                        		ADD CH,1
    78 00007CA3 80 FD 0A                        		CMP CH,CYLS
    79 00007CA6 72 BD                           		JB readloop
    80 00007CA8                                 ; 跳转到haribote.sys文件所在地
    81 00007CA8 88 2E 0FF0                      		MOV [0x0ff0],CH
    82 00007CAC E9 4551                         		JMP 0xc200
    83 00007CAF                                 
    84 00007CAF                                 error:
    85 00007CAF BE 7CC7                         		MOV		SI,msg
    86 00007CB2                                 putloop:
    87 00007CB2 8A 04                           		MOV AL,[SI]			; 方括号代表内存地址
    88 00007CB4 83 C6 01                        		ADD SI,1			; 给SI加1
    89 00007CB7 3C 00                           		CMP AL,0			
    90 00007CB9 74 09                           		JE	fin				; 如果上面的判断相等，跳转到哪儿，否则直接执行下面的指令
    91 00007CBB B4 0E                           		MOV AH,0x0e			; 显示一个文字
    92 00007CBD BB 000F                         		MOV BX,15			; 指定字符颜色、
    93 00007CC0 CD 10                           		INT 0x10			; 调用显卡BIOS
    94 00007CC2 EB EE                           		JMP putloop
    95 00007CC4                                 fin:
    96 00007CC4 F4                              		HLT
    97 00007CC5 EB FD                           		JMP fin
    98 00007CC7                                 msg:
    99 00007CC7 0A 0A                           		DB 0x0a, 0x0a		; 2个换行 
   100 00007CC9 6C 6F 61 64 20 65 72 72 6F 72   		DB "load error"
   101 00007CD3 0A                              		DB 0x0a				; 换行
   102 00007CD4 00                              		DB 0				
   103 00007CD5                                 
   104 00007CD5 00 00 00 00 00 00 00 00 00 00   		RESB 0x7dfe-$		; 填写0x00, 直到 0x7dfe
       00007CDF 00 00 00 00 00 00 00 00 00 00 
       00007CE9 00 00 00 00 00 00 00 00 00 00 
       00007CF3 00 00 00 00 00 00 00 00 00 00 
       00007CFD 00 00 00 00 00 00 00 00 00 00 
       00007D07 00 00 00 00 00 00 00 00 00 00 
       00007D11 00 00 00 00 00 00 00 00 00 00 
       00007D1B 00 00 00 00 00 00 00 00 00 00 
       00007D25 00 00 00 00 00 00 00 00 00 00 
       00007D2F 00 00 00 00 00 00 00 00 00 00 
       00007D39 00 00 00 00 00 00 00 00 00 00 
       00007D43 00 00 00 00 00 00 00 00 00 00 
       00007D4D 00 00 00 00 00 00 00 00 00 00 
       00007D57 00 00 00 00 00 00 00 00 00 00 
       00007D61 00 00 00 00 00 00 00 00 00 00 
       00007D6B 00 00 00 00 00 00 00 00 00 00 
       00007D75 00 00 00 00 00 00 00 00 00 00 
       00007D7F 00 00 00 00 00 00 00 00 00 00 
       00007D89 00 00 00 00 00 00 00 00 00 00 
       00007D93 00 00 00 00 00 00 00 00 00 00 
       00007D9D 00 00 00 00 00 00 00 00 00 00 
       00007DA7 00 00 00 00 00 00 00 00 00 00 
       00007DB1 00 00 00 00 00 00 00 00 00 00 
       00007DBB 00 00 00 00 00 00 00 00 00 00 
       00007DC5 00 00 00 00 00 00 00 00 00 00 
       00007DCF 00 00 00 00 00 00 00 00 00 00 
       00007DD9 00 00 00 00 00 00 00 00 00 00 
       00007DE3 00 00 00 00 00 00 00 00 00 00 
       00007DED 00 00 00 00 00 00 00 00 00 00 
       00007DF7 00 00 00 00 00 00 00 
   105 00007DFE                                 
   106 00007DFE 55 AA                           		DB 0x55, 0xaa
   107 00007E00                                 
   108 00007E00                                 
   109 00007E00                                 ; 汇编指令解释：
   110 00007E00                                 
   111 00007E00                                 ; DB(data byte): 写入一个字节, 或写入一个字符串(编译器自行寻找字符对应的编码并且转换为对应的指令, 不用自己找字符编码对照表)
   112 00007E00                                 
   113 00007E00                                 ; DW(data world): 写入双字节, 等同于16位
   114 00007E00                                 
   115 00007E00                                 ; DD(data double-word): 写入四字节，等同于32位
   116 00007E00                                 
   117 00007E00                                 ; RESB(reserve byte): 从现在的位置开始空出n个字节并且自动填充0x00(仅限于作者提供的编译器中), 关于line-39出现的带有美元符号的使用方法的含义为: 美元代表当前已输入字节，0x1fe-当前已输入字节得到它需要填充0x00的字节数
   118 00007E00                                 
   119 00007E00                                 ; ORG(origin): 指令会告诉nask(编译器), 在开始执行的时候，把这些机器语言指令装载到内存中的哪个地址(装载位置的起始地址)。如果没有它，有几个机器指令无法执行。并且美元符号的含义也发生改变：它不在表示输出文件的第几个字节，而是代表将要读入的内存地址. 这个指令也被称为"伪指令", 因为它不是机器指令.
   120 00007E00                                 
   121 00007E00                                 ; JMP(jump): 类似于C的GOTO关键字
   122 00007E00                                 
   123 00007E00                                 ; ADD: 加法指令
   124 00007E00                                 
   125 00007E00                                 ; CMP: 比较指令
   126 00007E00                                 
   127 00007E00                                 ; JE(jump if equal): CMP指令如果返回真，则执行它
   128 00007E00                                 
   129 00007E00                                 ; JC(jump if carry): 如果进位标志(carry flag)是1，就跳转
   130 00007E00                                 
   131 00007E00                                 ; JNC(jump if not carry): 如果进位标志(carry flag)是1, 就跳转
   132 00007E00                                 
   133 00007E00                                 ; JAE(jump if above or equal): 大于等于时跳转
   134 00007E00                                 
   135 00007E00                                 ; JBE(jump if below or equal): 小于等于时跳转
   136 00007E00                                 
   137 00007E00                                 ; JB(jump if below)
   138 00007E00                                 
   139 00007E00                                 ; INT(interrupt): 中断指令
   140 00007E00                                 
   141 00007E00                                 ; HLT: 让CPU进入待机状态
   142 00007E00                                 
   143 00007E00                                 ; MOV(move): 赋值指令, 虽然MOVE是移动的意思，但是与真正的移动不一样，当值被赋给其他的变量时，这个变量本身依然持有这个值，所以叫做“赋值”，关于这个指令，拆开解释:
   144 00007E00                                 ; 1. MOV AX,0			相当于AX=0
   145 00007E00                                 ; 2. MOV AX,SS			相当于AX=SS
   146 00007E00                                 ; 如果MOV 后面有括号，表示内存地址
   147 00007E00                                 
   148 00007E00                                 ; 关于上面的AX和SS是什么? 这是寄存器，通常由8个寄存器(均为16位寄存器):
   149 00007E00                                 ; AX ---- accumulator 累加寄存器
   150 00007E00                                 ; CX ---- counter 计数寄存器
   151 00007E00                                 ; DX ---- data 数据寄存器
   152 00007E00                                 ; BX ---- base 基址寄存器
   153 00007E00                                 ; SP ---- stack pointer 栈指针寄存器
   154 00007E00                                 ; BP ---- base pointer 基址指针寄存器
   155 00007E00                                 ; SI ---- source index 源址寄存器
   156 00007E00                                 ; DI ---- destination index 目的变址寄存器
   157 00007E00                                 ; 另外，上面的某些寄存器被分为:
   158 00007E00                                 ; AL ---- accumulator low 累加寄存器低位
   159 00007E00                                 ; CL ---- counter low
   160 00007E00                                 ; DL ---- data low
   161 00007E00                                 ; BL ---- base low
   162 00007E00                                 ; AH ---- accumulator high 累加寄存器高位
   163 00007E00                                 ; CH ---- counter high
   164 00007E00                                 ; DH ---- data high
   165 00007E00                                 ; BH ---- base high
   166 00007E00                                 ; 32位寄存器:
   167 00007E00                                 ; EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI, 在16位寄存器前面加个E就行了
   168 00007E00                                 ; 段寄存器:
   169 00007E00                                 ; ES ---- 附加段寄存器(extra segment)
   170 00007E00                                 ; CS ---- 代码段寄存器(code segment)
   171 00007E00                                 ; SS ---- 栈段寄存器(stack segment)
   172 00007E00                                 ; DS ---- 数据段寄存器(data segment)
   173 00007E00                                 ; FS ---- nameless(segment part 2)
   174 00007E00                                 ; GS ---- nameless(segment part 3)
   175 00007E00                                 
   176 00007E00                                 ; FAT参数解释:
   177 00007E00                                 ; FAT12(FAT12 Format): windows或ms-dos格式化出来的格式，我们使用它来搭载我们的系统以保证兼容性
   178 00007E00                                 ; 启动区(boot sector): 软盘的第一个扇区成为启动区, 计算机从软盘上每次读取512字节的内容，所以扇区大小为512, 第一个扇区的最两个字节必须是55 AA, 否则计算机将拒绝承认磁盘上有操作系统、
   179 00007E00                                 ; IPL(initial program loader): 启动程序加载器，这里只有512字节，但一般的操作系统非常大，这是不够用的。几乎所有的操作系统都把加载操作系统本身的程序放在IPL中，但本系统没有加载程序的功能，所以 "HELLOIPT" 仅仅是用来填充作用的, 如果名字不够8字节还得空格补齐。
   180 00007E00                                 
   181 00007E00                                 ; 这段代码的C语言翻译版(部分):
   182 00007E00                                 ; entry:
   183 00007E00                                 ;		AX = 0;
   184 00007E00                                 ;		SS = AX;
   185 00007E00                                 ;		SP = 0x7c00;
   186 00007E00                                 ;		DS = AX;
   187 00007E00                                 ;		ES = AX;
   188 00007E00                                 ;		SI = msg;
   189 00007E00                                 ; putloop:
   190 00007E00                                 ;		AL = BYTE[SI];
   191 00007E00                                 ;		SI = SI + 1;
   192 00007E00                                 ;		IF(AL == 0) {goto fin;}
   193 00007E00                                 ;		AH = 0X0e;
   194 00007E00                                 ;		BX = 15;
   195 00007E00                                 ;		INT 0x10;
   196 00007E00                                 ;		goto putloop;
   197 00007E00                                 ; fin:
   198 00007E00                                 ;		HLT;
   199 00007E00                                 ;		goto fin;
   200 00007E00                                 ; 就是将寄存器里面的字符一个一个打在屏幕上